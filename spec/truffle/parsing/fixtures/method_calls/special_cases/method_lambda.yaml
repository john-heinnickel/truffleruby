subject: "Method call"
description: "Special cases/method #lambda (Kernel#lambda)"
notes: >
  Ignore outer wrappers CatchBreakNode and FrameOnStackNode for clarity.
  Otherwise it should be focused on the following node:
    focused_on_node: "org.truffleruby.language.methods.CatchBreakNode"
focused_on_node: "org.truffleruby.core.inlined.InlinedLambdaNodeGen"
ruby: |
  lambda { }
ast: |
  InlinedLambdaNodeGen
      attributes:
          assumptions = [Assumption(valid, name=set_trace_func is not used)]
          parameters = org.truffleruby.language.dispatch.RubyCallNodeParameters@...
      children:
          block_ =
              BlockDefinitionNode
                  attributes:
                      breakID = org.truffleruby.language.control.BreakID@...
                      callTargets = ProcCallTargets(callTargetForProc = null, callTargetForLambda = block in <top (required)>, altCallTargetCompiler = org.truffleruby.parser.MethodTranslator$$Lambda$.../0x...@...)
                      frameOnStackMarkerSlot = -1
                      sharedMethodInfo = SharedMethodInfo(sourceSection = SourceSection(source=<parse_ast> [1 - 1], index=0, length=10, characters=lambda { }), staticLexicalScope =  :: Object, arity = Arity{preRequired = 0, optional = 0, hasRest = false, postRequired = 0, keywordArguments = [], requiredKeywordArgumentsCount = 0, hasKeywordsRest = false}, originName = block in <top (required)>, blockDepth = 1, parseName = block in <top (required)>, notes = <top (required)>, argumentDescriptors = [])
                      type = LAMBDA
                  children:
                      readSpecialVariableStorageNode =
                          TruffleKernelNodesFactory$GetSpecialVariableStorageNodeGen
                  call targets:
                      RubyLambdaRootNode
                          attributes:
                              arityForCheck = Arity{preRequired = 0, optional = 0, hasRest = false, postRequired = 0, keywordArguments = [], requiredKeywordArgumentsCount = 0, hasKeywordsRest = false}
                              breakID = org.truffleruby.language.control.BreakID@...
                              callTarget = block in <top (required)>
                              checkArityProfile = false
                              frameDescriptor = FrameDescriptor@...{#0:(self)}
                              instrumentationBits = 0
                              keywordArguments = false
                              localReturnProfile = false
                              lock = java.util.concurrent.locks.ReentrantLock@...[Unlocked]
                              matchingBreakProfile = false
                              matchingReturnProfile = false
                              nextProfile = false
                              nonMatchingBreakProfile = false
                              nonMatchingReturnProfile = false
                              polyglotRef = org.truffleruby.RubyLanguage@...
                              redoProfile = false
                              retryProfile = false
                              returnID = org.truffleruby.language.control.ReturnID@...
                              sharedMethodInfo = SharedMethodInfo(sourceSection = SourceSection(source=<parse_ast> [1 - 1], index=0, length=10, characters=lambda { }), staticLexicalScope =  :: Object, arity = Arity{preRequired = 0, optional = 0, hasRest = false, postRequired = 0, keywordArguments = [], requiredKeywordArgumentsCount = 0, hasKeywordsRest = false}, originName = block in <top (required)>, blockDepth = 1, parseName = block in <top (required)>, notes = <top (required)>, argumentDescriptors = [])
                              sourceSection = SourceSection(source=<parse_ast> [1 - 1], index=0, length=10, characters=lambda { })
                              split = HEURISTIC
                          children:
                              body =
                                  SequenceNode
                                      children:
                                          body = [
                                              WriteLocalVariableNode
                                                  attributes:
                                                      frameSlot = 0
                                                  children:
                                                      valueNode =
                                                          ProfileArgumentNodeGen
                                                              children:
                                                                  childNode_ =
                                                                      ReadSelfNode
                                              NilLiteralNode
                                                  attributes:
                                                      isImplicit = false
                                          ]
          selfNode_ =
              SelfNode