/******************************************************************************/
/* This file is generated by the bin/template script and should not be        */
/* modified manually. See                                                     */
/* templates/java/org/yarp/Nodes.java.erb                                     */
/* if you are looking to modify the                                           */
/* template                                                                   */
/******************************************************************************/
package org.yarp;

import java.lang.Override;
import java.lang.String;
import java.lang.StringBuilder;
import java.util.ArrayList;
import java.util.Arrays;

// GENERATED BY Nodes.java.erb
// @formatter:off
public abstract class Nodes {

    public static final class CallNodeFlags implements Comparable<CallNodeFlags> {

        // &. operator
        public static final int SAFE_NAVIGATION = 1 << 0;

        public static boolean isSafeNavigation(int flags) {
            return (flags & SAFE_NAVIGATION) != 0;
        }

        private final int flags;

        public CallNodeFlags(int flags) {
            this.flags = flags;
        }

        @Override
        public int hashCode() {
            return flags;
        }

        @Override
        public boolean equals(Object other) {
            if (!(other instanceof CallNodeFlags)) {
                return false;
            }

            return flags == ((CallNodeFlags) other).flags;
        }

        @Override
        public int compareTo(CallNodeFlags other) {
            return flags - other.flags;
        }

        public boolean isSafeNavigation() {
            return (flags & SAFE_NAVIGATION) != 0;
        }

    }

    public static final class RangeNodeFlags implements Comparable<RangeNodeFlags> {

        // ... operator
        public static final int EXCLUDE_END = 1 << 0;

        public static boolean isExcludeEnd(int flags) {
            return (flags & EXCLUDE_END) != 0;
        }

        private final int flags;

        public RangeNodeFlags(int flags) {
            this.flags = flags;
        }

        @Override
        public int hashCode() {
            return flags;
        }

        @Override
        public boolean equals(Object other) {
            if (!(other instanceof RangeNodeFlags)) {
                return false;
            }

            return flags == ((RangeNodeFlags) other).flags;
        }

        @Override
        public int compareTo(RangeNodeFlags other) {
            return flags - other.flags;
        }

        public boolean isExcludeEnd() {
            return (flags & EXCLUDE_END) != 0;
        }

    }

    public static final class RegularExpressionFlags implements Comparable<RegularExpressionFlags> {

        // i - ignores the case of characters when matching
        public static final int IGNORE_CASE = 1 << 0;

        // m - allows $ to match the end of lines within strings
        public static final int MULTI_LINE = 1 << 1;

        // x - ignores whitespace and allows comments in regular expressions
        public static final int EXTENDED = 1 << 2;

        // e - forces the EUC-JP encoding
        public static final int EUC_JP = 1 << 3;

        // n - forces the ASCII-8BIT encoding
        public static final int ASCII_8BIT = 1 << 4;

        // s - forces the Windows-31J encoding
        public static final int WINDOWS_31J = 1 << 5;

        // u - forces the UTF-8 encoding
        public static final int UTF_8 = 1 << 6;

        // o - only interpolates values into the regular expression once
        public static final int ONCE = 1 << 7;

        public static boolean isIgnoreCase(int flags) {
            return (flags & IGNORE_CASE) != 0;
        }

        public static boolean isMultiLine(int flags) {
            return (flags & MULTI_LINE) != 0;
        }

        public static boolean isExtended(int flags) {
            return (flags & EXTENDED) != 0;
        }

        public static boolean isEucJp(int flags) {
            return (flags & EUC_JP) != 0;
        }

        public static boolean isAscii8bit(int flags) {
            return (flags & ASCII_8BIT) != 0;
        }

        public static boolean isWindows31j(int flags) {
            return (flags & WINDOWS_31J) != 0;
        }

        public static boolean isUtf8(int flags) {
            return (flags & UTF_8) != 0;
        }

        public static boolean isOnce(int flags) {
            return (flags & ONCE) != 0;
        }

        private final int flags;

        public RegularExpressionFlags(int flags) {
            this.flags = flags;
        }

        @Override
        public int hashCode() {
            return flags;
        }

        @Override
        public boolean equals(Object other) {
            if (!(other instanceof RegularExpressionFlags)) {
                return false;
            }

            return flags == ((RegularExpressionFlags) other).flags;
        }

        @Override
        public int compareTo(RegularExpressionFlags other) {
            return flags - other.flags;
        }

        public boolean isIgnoreCase() {
            return (flags & IGNORE_CASE) != 0;
        }

        public boolean isMultiLine() {
            return (flags & MULTI_LINE) != 0;
        }

        public boolean isExtended() {
            return (flags & EXTENDED) != 0;
        }

        public boolean isEucJp() {
            return (flags & EUC_JP) != 0;
        }

        public boolean isAscii8bit() {
            return (flags & ASCII_8BIT) != 0;
        }

        public boolean isWindows31j() {
            return (flags & WINDOWS_31J) != 0;
        }

        public boolean isUtf8() {
            return (flags & UTF_8) != 0;
        }

        public boolean isOnce() {
            return (flags & ONCE) != 0;
        }

    }


    public static final class Location {
        public final int startOffset;
        public final int length;

        public Location(int startOffset, int length) {
            this.startOffset = startOffset;
            this.length = length;
        }

        public int length() {
            return length;
        }

        public int endOffset() {
            return startOffset + length;
        }
    }

    public static abstract class Node {

        public static final Node[] EMPTY_ARRAY = {};

        public final int startOffset;
        public final int length;

        public Node(int startOffset, int length) {
            this.startOffset = startOffset;
            this.length = length;
        }

        public int length() {
            return length;
        }

        public int endOffset() {
            return startOffset + length;
        }

        public abstract <T> T accept(AbstractNodeVisitor<T> visitor);

        public abstract Node[] childNodes();

        @Override
        public String toString() {
            return toString("");
        }

        private String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(indent).append(this.getClass().getSimpleName()).append('\n');
            for (Node child : childNodes()) {
                if (child != null) {
                    builder.append(child.toString(indent + "  "));
                }
            }
            return builder.toString();
        }
    }


    // Represents the use of the `alias` keyword.
    // 
    //     alias foo bar
    //     ^^^^^^^^^^^^^
    public static final class AliasNode extends Node {
        public final Node new_name;
        public final Node old_name;
        public final Location keyword_loc;

        public AliasNode(Node new_name, Node old_name, Location keyword_loc, int startOffset, int length) {
            super(startOffset, length);
            this.new_name = new_name;
            this.old_name = old_name;
            this.keyword_loc = keyword_loc;
        }

        public Node[] childNodes() {
            return new Node[] { new_name, old_name };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitAliasNode(this);
        }
    }

    // Represents an alternation pattern in pattern matching.
    // 
    //     foo => bar | baz
    //            ^^^^^^^^^
    public static final class AlternationPatternNode extends Node {
        public final Node left;
        public final Node right;
        public final Location operator_loc;

        public AlternationPatternNode(Node left, Node right, Location operator_loc, int startOffset, int length) {
            super(startOffset, length);
            this.left = left;
            this.right = right;
            this.operator_loc = operator_loc;
        }

        public Node[] childNodes() {
            return new Node[] { left, right };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitAlternationPatternNode(this);
        }
    }

    // Represents the use of the `&&` operator or the `and` keyword.
    // 
    //     left and right
    //     ^^^^^^^^^^^^^^
    public static final class AndNode extends Node {
        public final Node left;
        public final Node right;
        public final Location operator_loc;

        public AndNode(Node left, Node right, Location operator_loc, int startOffset, int length) {
            super(startOffset, length);
            this.left = left;
            this.right = right;
            this.operator_loc = operator_loc;
        }

        public Node[] childNodes() {
            return new Node[] { left, right };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitAndNode(this);
        }
    }

    // Represents a set of arguments to a method or a keyword.
    // 
    //     return foo, bar, baz
    //            ^^^^^^^^^^^^^
    public static final class ArgumentsNode extends Node {
        public final Node[] arguments;

        public ArgumentsNode(Node[] arguments, int startOffset, int length) {
            super(startOffset, length);
            this.arguments = arguments;
        }

        public Node[] childNodes() {
            return arguments;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitArgumentsNode(this);
        }
    }

    // Represents an array literal. This can be a regular array using brackets or
    // a special array using % like %w or %i.
    // 
    //     [1, 2, 3]
    //     ^^^^^^^^^
    public static final class ArrayNode extends Node {
        public final Node[] elements;
        public final Location opening_loc; // optional
        public final Location closing_loc; // optional

        public ArrayNode(Node[] elements, Location opening_loc, Location closing_loc, int startOffset, int length) {
            super(startOffset, length);
            this.elements = elements;
            this.opening_loc = opening_loc;
            this.closing_loc = closing_loc;
        }

        public Node[] childNodes() {
            return elements;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitArrayNode(this);
        }
    }

    // Represents an array pattern in pattern matching.
    // 
    //     foo in 1, 2
    //     ^^^^^^^^^^^
    // 
    //     foo in [1, 2]
    //     ^^^^^^^^^^^^^
    // 
    //     foo in *1
    //     ^^^^^^^^^
    // 
    //     foo in Bar[]
    //     ^^^^^^^^^^^^
    // 
    //     foo in Bar[1, 2, 3]
    //     ^^^^^^^^^^^^^^^^^^^
    public static final class ArrayPatternNode extends Node {
        public final Node constant; // optional
        public final Node[] requireds;
        public final Node rest; // optional
        public final Node[] posts;
        public final Location opening_loc; // optional
        public final Location closing_loc; // optional

        public ArrayPatternNode(Node constant, Node[] requireds, Node rest, Node[] posts, Location opening_loc, Location closing_loc, int startOffset, int length) {
            super(startOffset, length);
            this.constant = constant;
            this.requireds = requireds;
            this.rest = rest;
            this.posts = posts;
            this.opening_loc = opening_loc;
            this.closing_loc = closing_loc;
        }

        public Node[] childNodes() {
            ArrayList<Node> childNodes = new ArrayList<>();
            childNodes.add(constant);
            childNodes.addAll(Arrays.asList(requireds));
            childNodes.add(rest);
            childNodes.addAll(Arrays.asList(posts));
            return childNodes.toArray(EMPTY_ARRAY);
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitArrayPatternNode(this);
        }
    }

    // Represents a hash key/value pair.
    // 
    //     { a => b }
    //       ^^^^^^
    public static final class AssocNode extends Node {
        public final Node key;
        public final Node value; // optional
        public final Location operator_loc; // optional

        public AssocNode(Node key, Node value, Location operator_loc, int startOffset, int length) {
            super(startOffset, length);
            this.key = key;
            this.value = value;
            this.operator_loc = operator_loc;
        }

        public Node[] childNodes() {
            return new Node[] { key, value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitAssocNode(this);
        }
    }

    // Represents a splat in a hash literal.
    // 
    //     { **foo }
    //       ^^^^^
    public static final class AssocSplatNode extends Node {
        public final Node value; // optional
        public final Location operator_loc;

        public AssocSplatNode(Node value, Location operator_loc, int startOffset, int length) {
            super(startOffset, length);
            this.value = value;
            this.operator_loc = operator_loc;
        }

        public Node[] childNodes() {
            return new Node[] { value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitAssocSplatNode(this);
        }
    }

    // Represents reading a reference to a field in the previous match.
    // 
    //     $'
    //     ^^
    public static final class BackReferenceReadNode extends Node {

        public BackReferenceReadNode(int startOffset, int length) {
            super(startOffset, length);
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitBackReferenceReadNode(this);
        }
    }

    // Represents a begin statement.
    // 
    //     begin
    //       foo
    //     end
    //     ^^^^^
    public static final class BeginNode extends Node {
        public final Location begin_keyword_loc; // optional
        public final StatementsNode statements; // optional
        public final RescueNode rescue_clause; // optional
        public final ElseNode else_clause; // optional
        public final EnsureNode ensure_clause; // optional
        public final Location end_keyword_loc; // optional

        public BeginNode(Location begin_keyword_loc, StatementsNode statements, RescueNode rescue_clause, ElseNode else_clause, EnsureNode ensure_clause, Location end_keyword_loc, int startOffset, int length) {
            super(startOffset, length);
            this.begin_keyword_loc = begin_keyword_loc;
            this.statements = statements;
            this.rescue_clause = rescue_clause;
            this.else_clause = else_clause;
            this.ensure_clause = ensure_clause;
            this.end_keyword_loc = end_keyword_loc;
        }

        public Node[] childNodes() {
            return new Node[] { statements, rescue_clause, else_clause, ensure_clause };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitBeginNode(this);
        }
    }

    // Represents block method arguments.
    // 
    //     bar(&args)
    //     ^^^^^^^^^^
    public static final class BlockArgumentNode extends Node {
        public final Node expression; // optional
        public final Location operator_loc;

        public BlockArgumentNode(Node expression, Location operator_loc, int startOffset, int length) {
            super(startOffset, length);
            this.expression = expression;
            this.operator_loc = operator_loc;
        }

        public Node[] childNodes() {
            return new Node[] { expression };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitBlockArgumentNode(this);
        }
    }

    // Represents a block of ruby code.
    // 
    // [1, 2, 3].each { |i| puts x }
    //                ^^^^^^^^^^^^^^
    public static final class BlockNode extends Node {
        public final byte[][] locals;
        public final BlockParametersNode parameters; // optional
        public final Node statements; // optional
        public final Location opening_loc;
        public final Location closing_loc;

        public BlockNode(byte[][] locals, BlockParametersNode parameters, Node statements, Location opening_loc, Location closing_loc, int startOffset, int length) {
            super(startOffset, length);
            this.locals = locals;
            this.parameters = parameters;
            this.statements = statements;
            this.opening_loc = opening_loc;
            this.closing_loc = closing_loc;
        }

        public Node[] childNodes() {
            return new Node[] { parameters, statements };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitBlockNode(this);
        }
    }

    // Represents a block parameter to a method, block, or lambda definition.
    // 
    //     def a(&b)
    //           ^^
    //     end
    public static final class BlockParameterNode extends Node {
        public final Location name_loc; // optional
        public final Location operator_loc;

        public BlockParameterNode(Location name_loc, Location operator_loc, int startOffset, int length) {
            super(startOffset, length);
            this.name_loc = name_loc;
            this.operator_loc = operator_loc;
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitBlockParameterNode(this);
        }
    }

    // Represents a block's parameters declaration.
    // 
    //     -> (a, b = 1; local) { }
    //        ^^^^^^^^^^^^^^^^^
    // 
    //     foo do |a, b = 1; local|
    //            ^^^^^^^^^^^^^^^^^
    //     end
    public static final class BlockParametersNode extends Node {
        public final ParametersNode parameters; // optional
        public final Location[] locals;
        public final Location opening_loc; // optional
        public final Location closing_loc; // optional

        public BlockParametersNode(ParametersNode parameters, Location[] locals, Location opening_loc, Location closing_loc, int startOffset, int length) {
            super(startOffset, length);
            this.parameters = parameters;
            this.locals = locals;
            this.opening_loc = opening_loc;
            this.closing_loc = closing_loc;
        }

        public Node[] childNodes() {
            return new Node[] { parameters };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitBlockParametersNode(this);
        }
    }

    // Represents the use of the `break` keyword.
    // 
    //     break foo
    //     ^^^^^^^^^
    public static final class BreakNode extends Node {
        public final ArgumentsNode arguments; // optional
        public final Location keyword_loc;

        public BreakNode(ArgumentsNode arguments, Location keyword_loc, int startOffset, int length) {
            super(startOffset, length);
            this.arguments = arguments;
            this.keyword_loc = keyword_loc;
        }

        public Node[] childNodes() {
            return new Node[] { arguments };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitBreakNode(this);
        }
    }

    // Represents a method call, in all of the various forms that can take.
    // 
    //     foo
    //     ^^^
    // 
    //     foo()
    //     ^^^^^
    // 
    //     +foo
    //     ^^^^
    // 
    //     foo + bar
    //     ^^^^^^^^^
    // 
    //     foo.bar
    //     ^^^^^^^
    // 
    //     foo&.bar
    //     ^^^^^^^^
    public static final class CallNode extends Node {
        public final Node receiver; // optional
        public final Location operator_loc; // optional
        public final Location message_loc; // optional
        public final Location opening_loc; // optional
        public final ArgumentsNode arguments; // optional
        public final Location closing_loc; // optional
        public final BlockNode block; // optional
        public final int flags;
        public final byte[] name;

        public CallNode(Node receiver, Location operator_loc, Location message_loc, Location opening_loc, ArgumentsNode arguments, Location closing_loc, BlockNode block, int flags, byte[] name, int startOffset, int length) {
            super(startOffset, length);
            this.receiver = receiver;
            this.operator_loc = operator_loc;
            this.message_loc = message_loc;
            this.opening_loc = opening_loc;
            this.arguments = arguments;
            this.closing_loc = closing_loc;
            this.block = block;
            this.flags = flags;
            this.name = name;
        }

        public Node[] childNodes() {
            return new Node[] { receiver, arguments, block };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitCallNode(this);
        }
    }

    // Represents the use of the `&&=` operator on a call.
    // 
    //     foo.bar &&= value
    //     ^^^^^^^^^^^^^^^^^
    public static final class CallOperatorAndWriteNode extends Node {
        public final CallNode target;
        public final Location operator_loc;
        public final Node value;

        public CallOperatorAndWriteNode(CallNode target, Location operator_loc, Node value, int startOffset, int length) {
            super(startOffset, length);
            this.target = target;
            this.operator_loc = operator_loc;
            this.value = value;
        }

        public Node[] childNodes() {
            return new Node[] { target, value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitCallOperatorAndWriteNode(this);
        }
    }

    // Represents the use of the `||=` operator on a call.
    // 
    //     foo.bar ||= value
    //     ^^^^^^^^^^^^^^^^^
    public static final class CallOperatorOrWriteNode extends Node {
        public final CallNode target;
        public final Node value;
        public final Location operator_loc;

        public CallOperatorOrWriteNode(CallNode target, Node value, Location operator_loc, int startOffset, int length) {
            super(startOffset, length);
            this.target = target;
            this.value = value;
            this.operator_loc = operator_loc;
        }

        public Node[] childNodes() {
            return new Node[] { target, value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitCallOperatorOrWriteNode(this);
        }
    }

    // Represents the use of an assignment operator on a call.
    // 
    //     foo.bar += baz
    //     ^^^^^^^^^^^^^^
    public static final class CallOperatorWriteNode extends Node {
        public final CallNode target;
        public final Location operator_loc;
        public final Node value;
        public final byte[] operator_id;

        public CallOperatorWriteNode(CallNode target, Location operator_loc, Node value, byte[] operator_id, int startOffset, int length) {
            super(startOffset, length);
            this.target = target;
            this.operator_loc = operator_loc;
            this.value = value;
            this.operator_id = operator_id;
        }

        public Node[] childNodes() {
            return new Node[] { target, value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitCallOperatorWriteNode(this);
        }
    }

    // Represents assigning to a local variable in pattern matching.
    // 
    //     foo => [bar => baz]
    //            ^^^^^^^^^^^^
    public static final class CapturePatternNode extends Node {
        public final Node value;
        public final Node target;
        public final Location operator_loc;

        public CapturePatternNode(Node value, Node target, Location operator_loc, int startOffset, int length) {
            super(startOffset, length);
            this.value = value;
            this.target = target;
            this.operator_loc = operator_loc;
        }

        public Node[] childNodes() {
            return new Node[] { value, target };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitCapturePatternNode(this);
        }
    }

    // Represents the use of a case statement.
    // 
    // case true
    // ^^^^^^^^^
    // when false
    // end
    public static final class CaseNode extends Node {
        public final Node predicate; // optional
        public final Node[] conditions;
        public final ElseNode consequent; // optional
        public final Location case_keyword_loc;
        public final Location end_keyword_loc;

        public CaseNode(Node predicate, Node[] conditions, ElseNode consequent, Location case_keyword_loc, Location end_keyword_loc, int startOffset, int length) {
            super(startOffset, length);
            this.predicate = predicate;
            this.conditions = conditions;
            this.consequent = consequent;
            this.case_keyword_loc = case_keyword_loc;
            this.end_keyword_loc = end_keyword_loc;
        }

        public Node[] childNodes() {
            ArrayList<Node> childNodes = new ArrayList<>();
            childNodes.add(predicate);
            childNodes.addAll(Arrays.asList(conditions));
            childNodes.add(consequent);
            return childNodes.toArray(EMPTY_ARRAY);
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitCaseNode(this);
        }
    }

    // Represents a class declaration involving the `class` keyword.
    // 
    //     class Foo end
    //     ^^^^^^^^^^^^^
    public static final class ClassNode extends Node {
        public final byte[][] locals;
        public final Location class_keyword_loc;
        public final Node constant_path;
        public final Location inheritance_operator_loc; // optional
        public final Node superclass; // optional
        public final Node statements; // optional
        public final Location end_keyword_loc;

        public ClassNode(byte[][] locals, Location class_keyword_loc, Node constant_path, Location inheritance_operator_loc, Node superclass, Node statements, Location end_keyword_loc, int startOffset, int length) {
            super(startOffset, length);
            this.locals = locals;
            this.class_keyword_loc = class_keyword_loc;
            this.constant_path = constant_path;
            this.inheritance_operator_loc = inheritance_operator_loc;
            this.superclass = superclass;
            this.statements = statements;
            this.end_keyword_loc = end_keyword_loc;
        }

        public Node[] childNodes() {
            return new Node[] { constant_path, superclass, statements };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitClassNode(this);
        }
    }

    // Represents the use of the `&&=` operator for assignment to a class variable.
    // 
    //     @@target &&= value
    //     ^^^^^^^^^^^^^^^^
    public static final class ClassVariableOperatorAndWriteNode extends Node {
        public final Location name_loc;
        public final Location operator_loc;
        public final Node value;

        public ClassVariableOperatorAndWriteNode(Location name_loc, Location operator_loc, Node value, int startOffset, int length) {
            super(startOffset, length);
            this.name_loc = name_loc;
            this.operator_loc = operator_loc;
            this.value = value;
        }

        public Node[] childNodes() {
            return new Node[] { value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitClassVariableOperatorAndWriteNode(this);
        }
    }

    // Represents the use of the `||=` operator for assignment to a class variable.
    // 
    //     @@target ||= value
    //     ^^^^^^^^^^^^^^^^^^
    public static final class ClassVariableOperatorOrWriteNode extends Node {
        public final Location name_loc;
        public final Location operator_loc;
        public final Node value;

        public ClassVariableOperatorOrWriteNode(Location name_loc, Location operator_loc, Node value, int startOffset, int length) {
            super(startOffset, length);
            this.name_loc = name_loc;
            this.operator_loc = operator_loc;
            this.value = value;
        }

        public Node[] childNodes() {
            return new Node[] { value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitClassVariableOperatorOrWriteNode(this);
        }
    }

    // Represents assigning to a class variable using an operator that isn't `=`.
    // 
    //     @@target += value
    //     ^^^^^^^^^^^^^^^^^
    public static final class ClassVariableOperatorWriteNode extends Node {
        public final Location name_loc;
        public final Location operator_loc;
        public final Node value;
        public final byte[] operator;

        public ClassVariableOperatorWriteNode(Location name_loc, Location operator_loc, Node value, byte[] operator, int startOffset, int length) {
            super(startOffset, length);
            this.name_loc = name_loc;
            this.operator_loc = operator_loc;
            this.value = value;
            this.operator = operator;
        }

        public Node[] childNodes() {
            return new Node[] { value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitClassVariableOperatorWriteNode(this);
        }
    }

    // Represents referencing a class variable.
    // 
    //     @@foo
    //     ^^^^^
    public static final class ClassVariableReadNode extends Node {

        public ClassVariableReadNode(int startOffset, int length) {
            super(startOffset, length);
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitClassVariableReadNode(this);
        }
    }

    // Represents writing to a class variable.
    // 
    //     @@foo = 1
    //     ^^^^^^^^^
    public static final class ClassVariableWriteNode extends Node {
        public final Location name_loc;
        public final Node value; // optional
        public final Location operator_loc; // optional

        public ClassVariableWriteNode(Location name_loc, Node value, Location operator_loc, int startOffset, int length) {
            super(startOffset, length);
            this.name_loc = name_loc;
            this.value = value;
            this.operator_loc = operator_loc;
        }

        public Node[] childNodes() {
            return new Node[] { value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitClassVariableWriteNode(this);
        }
    }

    // Represents the use of the `&&=` operator for assignment to a constant.
    // 
    //     Target &&= value
    //     ^^^^^^^^^^^^^^^^
    public static final class ConstantOperatorAndWriteNode extends Node {
        public final Location name_loc;
        public final Location operator_loc;
        public final Node value;

        public ConstantOperatorAndWriteNode(Location name_loc, Location operator_loc, Node value, int startOffset, int length) {
            super(startOffset, length);
            this.name_loc = name_loc;
            this.operator_loc = operator_loc;
            this.value = value;
        }

        public Node[] childNodes() {
            return new Node[] { value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitConstantOperatorAndWriteNode(this);
        }
    }

    // Represents the use of the `||=` operator for assignment to a constant.
    // 
    //     Target ||= value
    //     ^^^^^^^^^^^^^^^^
    public static final class ConstantOperatorOrWriteNode extends Node {
        public final Location name_loc;
        public final Location operator_loc;
        public final Node value;

        public ConstantOperatorOrWriteNode(Location name_loc, Location operator_loc, Node value, int startOffset, int length) {
            super(startOffset, length);
            this.name_loc = name_loc;
            this.operator_loc = operator_loc;
            this.value = value;
        }

        public Node[] childNodes() {
            return new Node[] { value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitConstantOperatorOrWriteNode(this);
        }
    }

    // Represents assigning to a constant using an operator that isn't `=`.
    // 
    //     Target += value
    //     ^^^^^^^^^^^^^^^
    public static final class ConstantOperatorWriteNode extends Node {
        public final Location name_loc;
        public final Location operator_loc;
        public final Node value;
        public final byte[] operator;

        public ConstantOperatorWriteNode(Location name_loc, Location operator_loc, Node value, byte[] operator, int startOffset, int length) {
            super(startOffset, length);
            this.name_loc = name_loc;
            this.operator_loc = operator_loc;
            this.value = value;
            this.operator = operator;
        }

        public Node[] childNodes() {
            return new Node[] { value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitConstantOperatorWriteNode(this);
        }
    }

    // Represents accessing a constant through a path of `::` operators.
    // 
    //     Foo::Bar
    //     ^^^^^^^^
    public static final class ConstantPathNode extends Node {
        public final Node parent; // optional
        public final Node child;
        public final Location delimiter_loc;

        public ConstantPathNode(Node parent, Node child, Location delimiter_loc, int startOffset, int length) {
            super(startOffset, length);
            this.parent = parent;
            this.child = child;
            this.delimiter_loc = delimiter_loc;
        }

        public Node[] childNodes() {
            return new Node[] { parent, child };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitConstantPathNode(this);
        }
    }

    // Represents the use of the `&&=` operator for assignment to a constant path.
    // 
    //     Parent::Child &&= value
    //     ^^^^^^^^^^^^^^^^^^^^^^^
    public static final class ConstantPathOperatorAndWriteNode extends Node {
        public final ConstantPathNode target;
        public final Location operator_loc;
        public final Node value;

        public ConstantPathOperatorAndWriteNode(ConstantPathNode target, Location operator_loc, Node value, int startOffset, int length) {
            super(startOffset, length);
            this.target = target;
            this.operator_loc = operator_loc;
            this.value = value;
        }

        public Node[] childNodes() {
            return new Node[] { target, value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitConstantPathOperatorAndWriteNode(this);
        }
    }

    // Represents the use of the `||=` operator for assignment to a constant path.
    // 
    //     Parent::Child ||= value
    //     ^^^^^^^^^^^^^^^^^^^^^^^
    public static final class ConstantPathOperatorOrWriteNode extends Node {
        public final ConstantPathNode target;
        public final Location operator_loc;
        public final Node value;

        public ConstantPathOperatorOrWriteNode(ConstantPathNode target, Location operator_loc, Node value, int startOffset, int length) {
            super(startOffset, length);
            this.target = target;
            this.operator_loc = operator_loc;
            this.value = value;
        }

        public Node[] childNodes() {
            return new Node[] { target, value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitConstantPathOperatorOrWriteNode(this);
        }
    }

    // Represents assigning to a constant path using an operator that isn't `=`.
    // 
    //     Parent::Child += value
    //     ^^^^^^^^^^^^^^^^^^^^^^
    public static final class ConstantPathOperatorWriteNode extends Node {
        public final ConstantPathNode target;
        public final Location operator_loc;
        public final Node value;
        public final byte[] operator;

        public ConstantPathOperatorWriteNode(ConstantPathNode target, Location operator_loc, Node value, byte[] operator, int startOffset, int length) {
            super(startOffset, length);
            this.target = target;
            this.operator_loc = operator_loc;
            this.value = value;
            this.operator = operator;
        }

        public Node[] childNodes() {
            return new Node[] { target, value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitConstantPathOperatorWriteNode(this);
        }
    }

    // Represents writing to a constant.
    // 
    //     Foo = 1
    //     ^^^^^^^
    // 
    //     Foo::Bar = 1
    //     ^^^^^^^^^^^^
    public static final class ConstantPathWriteNode extends Node {
        public final Node target;
        public final Location operator_loc; // optional
        public final Node value; // optional

        public ConstantPathWriteNode(Node target, Location operator_loc, Node value, int startOffset, int length) {
            super(startOffset, length);
            this.target = target;
            this.operator_loc = operator_loc;
            this.value = value;
        }

        public Node[] childNodes() {
            return new Node[] { target, value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitConstantPathWriteNode(this);
        }
    }

    // Represents referencing a constant.
    // 
    //     Foo
    //     ^^^
    public static final class ConstantReadNode extends Node {

        public ConstantReadNode(int startOffset, int length) {
            super(startOffset, length);
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitConstantReadNode(this);
        }
    }

    // Represents a method definition.
    // 
    //     def method
    //     end
    //     ^^^^^^^^^^
    public static final class DefNode extends Node {
        public final int serializedLength;
        public final Location name_loc;
        public final Node receiver; // optional
        public final ParametersNode parameters; // optional
        public final Node statements; // optional
        public final byte[][] locals;
        public final Location def_keyword_loc;
        public final Location operator_loc; // optional
        public final Location lparen_loc; // optional
        public final Location rparen_loc; // optional
        public final Location equal_loc; // optional
        public final Location end_keyword_loc; // optional

        public DefNode(int serializedLength, Location name_loc, Node receiver, ParametersNode parameters, Node statements, byte[][] locals, Location def_keyword_loc, Location operator_loc, Location lparen_loc, Location rparen_loc, Location equal_loc, Location end_keyword_loc, int startOffset, int length) {
            super(startOffset, length);
            this.serializedLength = serializedLength;
            this.name_loc = name_loc;
            this.receiver = receiver;
            this.parameters = parameters;
            this.statements = statements;
            this.locals = locals;
            this.def_keyword_loc = def_keyword_loc;
            this.operator_loc = operator_loc;
            this.lparen_loc = lparen_loc;
            this.rparen_loc = rparen_loc;
            this.equal_loc = equal_loc;
            this.end_keyword_loc = end_keyword_loc;
        }

        public Node[] childNodes() {
            return new Node[] { receiver, parameters, statements };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitDefNode(this);
        }
    }

    // Represents the use of the `defined?` keyword.
    // 
    //     defined?(a)
    //     ^^^^^^^^^^^
    public static final class DefinedNode extends Node {
        public final Location lparen_loc; // optional
        public final Node value;
        public final Location rparen_loc; // optional
        public final Location keyword_loc;

        public DefinedNode(Location lparen_loc, Node value, Location rparen_loc, Location keyword_loc, int startOffset, int length) {
            super(startOffset, length);
            this.lparen_loc = lparen_loc;
            this.value = value;
            this.rparen_loc = rparen_loc;
            this.keyword_loc = keyword_loc;
        }

        public Node[] childNodes() {
            return new Node[] { value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitDefinedNode(this);
        }
    }

    // Represents an `else` clause in a `case`, `if`, or `unless` statement.
    // 
    //     if a then b else c end
    //                 ^^^^^^^^^^
    public static final class ElseNode extends Node {
        public final Location else_keyword_loc;
        public final StatementsNode statements; // optional
        public final Location end_keyword_loc; // optional

        public ElseNode(Location else_keyword_loc, StatementsNode statements, Location end_keyword_loc, int startOffset, int length) {
            super(startOffset, length);
            this.else_keyword_loc = else_keyword_loc;
            this.statements = statements;
            this.end_keyword_loc = end_keyword_loc;
        }

        public Node[] childNodes() {
            return new Node[] { statements };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitElseNode(this);
        }
    }

    // Represents an interpolated set of statements.
    // 
    //     "foo #{bar}"
    //          ^^^^^^
    public static final class EmbeddedStatementsNode extends Node {
        public final Location opening_loc;
        public final StatementsNode statements; // optional
        public final Location closing_loc;

        public EmbeddedStatementsNode(Location opening_loc, StatementsNode statements, Location closing_loc, int startOffset, int length) {
            super(startOffset, length);
            this.opening_loc = opening_loc;
            this.statements = statements;
            this.closing_loc = closing_loc;
        }

        public Node[] childNodes() {
            return new Node[] { statements };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitEmbeddedStatementsNode(this);
        }
    }

    // Represents an interpolated variable.
    // 
    //     "foo #@bar"
    //          ^^^^^
    public static final class EmbeddedVariableNode extends Node {
        public final Location operator_loc;
        public final Node variable;

        public EmbeddedVariableNode(Location operator_loc, Node variable, int startOffset, int length) {
            super(startOffset, length);
            this.operator_loc = operator_loc;
            this.variable = variable;
        }

        public Node[] childNodes() {
            return new Node[] { variable };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitEmbeddedVariableNode(this);
        }
    }

    // Represents an `ensure` clause in a `begin` statement.
    // 
    //     begin
    //       foo
    //     ensure
    //     ^^^^^^
    //       bar
    //     end
    public static final class EnsureNode extends Node {
        public final Location ensure_keyword_loc;
        public final StatementsNode statements; // optional
        public final Location end_keyword_loc;

        public EnsureNode(Location ensure_keyword_loc, StatementsNode statements, Location end_keyword_loc, int startOffset, int length) {
            super(startOffset, length);
            this.ensure_keyword_loc = ensure_keyword_loc;
            this.statements = statements;
            this.end_keyword_loc = end_keyword_loc;
        }

        public Node[] childNodes() {
            return new Node[] { statements };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitEnsureNode(this);
        }
    }

    // Represents the use of the literal `false` keyword.
    // 
    //     false
    //     ^^^^^
    public static final class FalseNode extends Node {

        public FalseNode(int startOffset, int length) {
            super(startOffset, length);
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitFalseNode(this);
        }
    }

    // Represents a find pattern in pattern matching.
    // 
    //     foo in *bar, baz, *qux
    //     ^^^^^^^^^^^^^^^^^^^^^^
    // 
    //     foo in [*bar, baz, *qux]
    //     ^^^^^^^^^^^^^^^^^^^^^^^^
    // 
    //     foo in Foo(*bar, baz, *qux)
    //     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
    public static final class FindPatternNode extends Node {
        public final Node constant; // optional
        public final Node left;
        public final Node[] requireds;
        public final Node right;
        public final Location opening_loc; // optional
        public final Location closing_loc; // optional

        public FindPatternNode(Node constant, Node left, Node[] requireds, Node right, Location opening_loc, Location closing_loc, int startOffset, int length) {
            super(startOffset, length);
            this.constant = constant;
            this.left = left;
            this.requireds = requireds;
            this.right = right;
            this.opening_loc = opening_loc;
            this.closing_loc = closing_loc;
        }

        public Node[] childNodes() {
            ArrayList<Node> childNodes = new ArrayList<>();
            childNodes.add(constant);
            childNodes.add(left);
            childNodes.addAll(Arrays.asList(requireds));
            childNodes.add(right);
            return childNodes.toArray(EMPTY_ARRAY);
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitFindPatternNode(this);
        }
    }

    // Represents a floating point number literal.
    // 
    //     1.0
    //     ^^^
    public static final class FloatNode extends Node {

        public FloatNode(int startOffset, int length) {
            super(startOffset, length);
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitFloatNode(this);
        }
    }

    // Represents the use of the `for` keyword.
    // 
    //     for i in a end
    //     ^^^^^^^^^^^^^^
    public static final class ForNode extends Node {
        public final Node index;
        public final Node collection;
        public final StatementsNode statements; // optional
        public final Location for_keyword_loc;
        public final Location in_keyword_loc;
        public final Location do_keyword_loc; // optional
        public final Location end_keyword_loc;

        public ForNode(Node index, Node collection, StatementsNode statements, Location for_keyword_loc, Location in_keyword_loc, Location do_keyword_loc, Location end_keyword_loc, int startOffset, int length) {
            super(startOffset, length);
            this.index = index;
            this.collection = collection;
            this.statements = statements;
            this.for_keyword_loc = for_keyword_loc;
            this.in_keyword_loc = in_keyword_loc;
            this.do_keyword_loc = do_keyword_loc;
            this.end_keyword_loc = end_keyword_loc;
        }

        public Node[] childNodes() {
            return new Node[] { index, collection, statements };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitForNode(this);
        }
    }

    // Represents forwarding all arguments to this method to another method.
    // 
    //     def foo(...)
    //       bar(...)
    //       ^^^^^^^^
    //     end
    public static final class ForwardingArgumentsNode extends Node {

        public ForwardingArgumentsNode(int startOffset, int length) {
            super(startOffset, length);
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitForwardingArgumentsNode(this);
        }
    }

    // Represents the use of the forwarding parameter in a method, block, or lambda declaration.
    // 
    //     def foo(...)
    //             ^^^
    //     end
    public static final class ForwardingParameterNode extends Node {

        public ForwardingParameterNode(int startOffset, int length) {
            super(startOffset, length);
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitForwardingParameterNode(this);
        }
    }

    // Represents the use of the `super` keyword without parentheses or arguments.
    // 
    //     super
    //     ^^^^^
    public static final class ForwardingSuperNode extends Node {
        public final BlockNode block; // optional

        public ForwardingSuperNode(BlockNode block, int startOffset, int length) {
            super(startOffset, length);
            this.block = block;
        }

        public Node[] childNodes() {
            return new Node[] { block };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitForwardingSuperNode(this);
        }
    }

    // Represents the use of the `&&=` operator for assignment to a global variable.
    // 
    //     $target &&= value
    //     ^^^^^^^^^^^^^^^^^
    public static final class GlobalVariableOperatorAndWriteNode extends Node {
        public final Location name_loc;
        public final Location operator_loc;
        public final Node value;

        public GlobalVariableOperatorAndWriteNode(Location name_loc, Location operator_loc, Node value, int startOffset, int length) {
            super(startOffset, length);
            this.name_loc = name_loc;
            this.operator_loc = operator_loc;
            this.value = value;
        }

        public Node[] childNodes() {
            return new Node[] { value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitGlobalVariableOperatorAndWriteNode(this);
        }
    }

    // Represents the use of the `||=` operator for assignment to a global variable.
    // 
    //     $target ||= value
    //     ^^^^^^^^^^^^^^^^^
    public static final class GlobalVariableOperatorOrWriteNode extends Node {
        public final Location name_loc;
        public final Location operator_loc;
        public final Node value;

        public GlobalVariableOperatorOrWriteNode(Location name_loc, Location operator_loc, Node value, int startOffset, int length) {
            super(startOffset, length);
            this.name_loc = name_loc;
            this.operator_loc = operator_loc;
            this.value = value;
        }

        public Node[] childNodes() {
            return new Node[] { value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitGlobalVariableOperatorOrWriteNode(this);
        }
    }

    // Represents assigning to a global variable using an operator that isn't `=`.
    // 
    //     $target += value
    //     ^^^^^^^^^^^^^^^^
    public static final class GlobalVariableOperatorWriteNode extends Node {
        public final Location name_loc;
        public final Location operator_loc;
        public final Node value;
        public final byte[] operator;

        public GlobalVariableOperatorWriteNode(Location name_loc, Location operator_loc, Node value, byte[] operator, int startOffset, int length) {
            super(startOffset, length);
            this.name_loc = name_loc;
            this.operator_loc = operator_loc;
            this.value = value;
            this.operator = operator;
        }

        public Node[] childNodes() {
            return new Node[] { value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitGlobalVariableOperatorWriteNode(this);
        }
    }

    // Represents referencing a global variable.
    // 
    //     $foo
    //     ^^^^
    public static final class GlobalVariableReadNode extends Node {

        public GlobalVariableReadNode(int startOffset, int length) {
            super(startOffset, length);
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitGlobalVariableReadNode(this);
        }
    }

    // Represents writing to a global variable.
    // 
    //     $foo = 1
    //     ^^^^^^^^
    public static final class GlobalVariableWriteNode extends Node {
        public final Location name_loc;
        public final Location operator_loc; // optional
        public final Node value; // optional

        public GlobalVariableWriteNode(Location name_loc, Location operator_loc, Node value, int startOffset, int length) {
            super(startOffset, length);
            this.name_loc = name_loc;
            this.operator_loc = operator_loc;
            this.value = value;
        }

        public Node[] childNodes() {
            return new Node[] { value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitGlobalVariableWriteNode(this);
        }
    }

    // Represents a hash literal.
    // 
    //     { a => b }
    //     ^^^^^^^^^^
    public static final class HashNode extends Node {
        public final Location opening_loc;
        public final Node[] elements;
        public final Location closing_loc;

        public HashNode(Location opening_loc, Node[] elements, Location closing_loc, int startOffset, int length) {
            super(startOffset, length);
            this.opening_loc = opening_loc;
            this.elements = elements;
            this.closing_loc = closing_loc;
        }

        public Node[] childNodes() {
            return elements;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitHashNode(this);
        }
    }

    // Represents a hash pattern in pattern matching.
    // 
    //     foo => { a: 1, b: 2 }
    //            ^^^^^^^^^^^^^^
    // 
    //     foo => { a: 1, b: 2, **c }
    //            ^^^^^^^^^^^^^^^^^^^
    public static final class HashPatternNode extends Node {
        public final Node constant; // optional
        public final Node[] assocs;
        public final Node kwrest; // optional
        public final Location opening_loc; // optional
        public final Location closing_loc; // optional

        public HashPatternNode(Node constant, Node[] assocs, Node kwrest, Location opening_loc, Location closing_loc, int startOffset, int length) {
            super(startOffset, length);
            this.constant = constant;
            this.assocs = assocs;
            this.kwrest = kwrest;
            this.opening_loc = opening_loc;
            this.closing_loc = closing_loc;
        }

        public Node[] childNodes() {
            ArrayList<Node> childNodes = new ArrayList<>();
            childNodes.add(constant);
            childNodes.addAll(Arrays.asList(assocs));
            childNodes.add(kwrest);
            return childNodes.toArray(EMPTY_ARRAY);
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitHashPatternNode(this);
        }
    }

    // Represents the use of the `if` keyword, either in the block form or the modifier form.
    // 
    //     bar if foo
    //     ^^^^^^^^^^
    // 
    //     if foo then bar end
    //     ^^^^^^^^^^^^^^^^^^^
    public static final class IfNode extends Node {
        public final Location if_keyword_loc; // optional
        public final Node predicate;
        public final StatementsNode statements; // optional
        public final Node consequent; // optional
        public final Location end_keyword_loc; // optional

        public IfNode(Location if_keyword_loc, Node predicate, StatementsNode statements, Node consequent, Location end_keyword_loc, int startOffset, int length) {
            super(startOffset, length);
            this.if_keyword_loc = if_keyword_loc;
            this.predicate = predicate;
            this.statements = statements;
            this.consequent = consequent;
            this.end_keyword_loc = end_keyword_loc;
        }

        public Node[] childNodes() {
            return new Node[] { predicate, statements, consequent };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitIfNode(this);
        }
    }

    // Represents an imaginary number literal.
    // 
    //     1.0i
    //     ^^^^
    public static final class ImaginaryNode extends Node {
        public final Node numeric;

        public ImaginaryNode(Node numeric, int startOffset, int length) {
            super(startOffset, length);
            this.numeric = numeric;
        }

        public Node[] childNodes() {
            return new Node[] { numeric };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitImaginaryNode(this);
        }
    }

    // Represents the use of the `in` keyword in a case statement.
    // 
    //     case a; in b then c end
    //             ^^^^^^^^^^^
    public static final class InNode extends Node {
        public final Node pattern;
        public final StatementsNode statements; // optional
        public final Location in_loc;
        public final Location then_loc; // optional

        public InNode(Node pattern, StatementsNode statements, Location in_loc, Location then_loc, int startOffset, int length) {
            super(startOffset, length);
            this.pattern = pattern;
            this.statements = statements;
            this.in_loc = in_loc;
            this.then_loc = then_loc;
        }

        public Node[] childNodes() {
            return new Node[] { pattern, statements };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitInNode(this);
        }
    }

    // Represents the use of the `&&=` operator for assignment to an instance variable.
    // 
    //     @target &&= value
    //     ^^^^^^^^^^^^^^^^^
    public static final class InstanceVariableOperatorAndWriteNode extends Node {
        public final Location name_loc;
        public final Location operator_loc;
        public final Node value;

        public InstanceVariableOperatorAndWriteNode(Location name_loc, Location operator_loc, Node value, int startOffset, int length) {
            super(startOffset, length);
            this.name_loc = name_loc;
            this.operator_loc = operator_loc;
            this.value = value;
        }

        public Node[] childNodes() {
            return new Node[] { value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitInstanceVariableOperatorAndWriteNode(this);
        }
    }

    // Represents the use of the `||=` operator for assignment to an instance variable.
    // 
    //     @target ||= value
    //     ^^^^^^^^^^^^^^^^^
    public static final class InstanceVariableOperatorOrWriteNode extends Node {
        public final Location name_loc;
        public final Location operator_loc;
        public final Node value;

        public InstanceVariableOperatorOrWriteNode(Location name_loc, Location operator_loc, Node value, int startOffset, int length) {
            super(startOffset, length);
            this.name_loc = name_loc;
            this.operator_loc = operator_loc;
            this.value = value;
        }

        public Node[] childNodes() {
            return new Node[] { value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitInstanceVariableOperatorOrWriteNode(this);
        }
    }

    // Represents assigning to an instance variable using an operator that isn't `=`.
    // 
    //     @target += value
    //     ^^^^^^^^^^^^^^^^
    public static final class InstanceVariableOperatorWriteNode extends Node {
        public final Location name_loc;
        public final Location operator_loc;
        public final Node value;
        public final byte[] operator;

        public InstanceVariableOperatorWriteNode(Location name_loc, Location operator_loc, Node value, byte[] operator, int startOffset, int length) {
            super(startOffset, length);
            this.name_loc = name_loc;
            this.operator_loc = operator_loc;
            this.value = value;
            this.operator = operator;
        }

        public Node[] childNodes() {
            return new Node[] { value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitInstanceVariableOperatorWriteNode(this);
        }
    }

    // Represents referencing an instance variable.
    // 
    //     @foo
    //     ^^^^
    public static final class InstanceVariableReadNode extends Node {

        public InstanceVariableReadNode(int startOffset, int length) {
            super(startOffset, length);
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitInstanceVariableReadNode(this);
        }
    }

    // Represents writing to an instance variable.
    // 
    //     @foo = 1
    //     ^^^^^^^^
    public static final class InstanceVariableWriteNode extends Node {
        public final Location name_loc;
        public final Node value; // optional
        public final Location operator_loc; // optional

        public InstanceVariableWriteNode(Location name_loc, Node value, Location operator_loc, int startOffset, int length) {
            super(startOffset, length);
            this.name_loc = name_loc;
            this.value = value;
            this.operator_loc = operator_loc;
        }

        public Node[] childNodes() {
            return new Node[] { value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitInstanceVariableWriteNode(this);
        }
    }

    // Represents an integer number literal.
    // 
    //     1
    //     ^
    public static final class IntegerNode extends Node {

        public IntegerNode(int startOffset, int length) {
            super(startOffset, length);
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitIntegerNode(this);
        }
    }

    // Represents a regular expression literal that contains interpolation.
    // 
    //     /foo #{bar} baz/
    //     ^^^^^^^^^^^^^^^^
    public static final class InterpolatedRegularExpressionNode extends Node {
        public final Location opening_loc;
        public final Node[] parts;
        public final Location closing_loc;
        public final int flags;

        public InterpolatedRegularExpressionNode(Location opening_loc, Node[] parts, Location closing_loc, int flags, int startOffset, int length) {
            super(startOffset, length);
            this.opening_loc = opening_loc;
            this.parts = parts;
            this.closing_loc = closing_loc;
            this.flags = flags;
        }

        public Node[] childNodes() {
            return parts;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitInterpolatedRegularExpressionNode(this);
        }
    }

    // Represents a string literal that contains interpolation.
    // 
    //     "foo #{bar} baz"
    //     ^^^^^^^^^^^^^^^^
    public static final class InterpolatedStringNode extends Node {
        public final Location opening_loc; // optional
        public final Node[] parts;
        public final Location closing_loc; // optional

        public InterpolatedStringNode(Location opening_loc, Node[] parts, Location closing_loc, int startOffset, int length) {
            super(startOffset, length);
            this.opening_loc = opening_loc;
            this.parts = parts;
            this.closing_loc = closing_loc;
        }

        public Node[] childNodes() {
            return parts;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitInterpolatedStringNode(this);
        }
    }

    // Represents a symbol literal that contains interpolation.
    // 
    //     :"foo #{bar} baz"
    //     ^^^^^^^^^^^^^^^^^
    public static final class InterpolatedSymbolNode extends Node {
        public final Location opening_loc; // optional
        public final Node[] parts;
        public final Location closing_loc; // optional

        public InterpolatedSymbolNode(Location opening_loc, Node[] parts, Location closing_loc, int startOffset, int length) {
            super(startOffset, length);
            this.opening_loc = opening_loc;
            this.parts = parts;
            this.closing_loc = closing_loc;
        }

        public Node[] childNodes() {
            return parts;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitInterpolatedSymbolNode(this);
        }
    }

    // Represents an xstring literal that contains interpolation.
    // 
    //     `foo #{bar} baz`
    //     ^^^^^^^^^^^^^^^^
    public static final class InterpolatedXStringNode extends Node {
        public final Location opening_loc;
        public final Node[] parts;
        public final Location closing_loc;

        public InterpolatedXStringNode(Location opening_loc, Node[] parts, Location closing_loc, int startOffset, int length) {
            super(startOffset, length);
            this.opening_loc = opening_loc;
            this.parts = parts;
            this.closing_loc = closing_loc;
        }

        public Node[] childNodes() {
            return parts;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitInterpolatedXStringNode(this);
        }
    }

    // Represents a hash literal without opening and closing braces.
    // 
    //     foo(a: b)
    //         ^^^^
    public static final class KeywordHashNode extends Node {
        public final Node[] elements;

        public KeywordHashNode(Node[] elements, int startOffset, int length) {
            super(startOffset, length);
            this.elements = elements;
        }

        public Node[] childNodes() {
            return elements;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitKeywordHashNode(this);
        }
    }

    // Represents a keyword parameter to a method, block, or lambda definition.
    // 
    //     def a(b:)
    //           ^^
    //     end
    // 
    //     def a(b: 1)
    //           ^^^^
    //     end
    public static final class KeywordParameterNode extends Node {
        public final Location name_loc;
        public final Node value; // optional

        public KeywordParameterNode(Location name_loc, Node value, int startOffset, int length) {
            super(startOffset, length);
            this.name_loc = name_loc;
            this.value = value;
        }

        public Node[] childNodes() {
            return new Node[] { value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitKeywordParameterNode(this);
        }
    }

    // Represents a keyword rest parameter to a method, block, or lambda definition.
    // 
    //     def a(**b)
    //           ^^^
    //     end
    public static final class KeywordRestParameterNode extends Node {
        public final Location operator_loc;
        public final Location name_loc; // optional

        public KeywordRestParameterNode(Location operator_loc, Location name_loc, int startOffset, int length) {
            super(startOffset, length);
            this.operator_loc = operator_loc;
            this.name_loc = name_loc;
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitKeywordRestParameterNode(this);
        }
    }

    // Represents using a lambda literal (not the lambda method call).
    // 
    //     ->(value) { value * 2 }
    //     ^^^^^^^^^^^^^^^^^^^^^^^
    public static final class LambdaNode extends Node {
        public final byte[][] locals;
        public final Location opening_loc;
        public final BlockParametersNode parameters; // optional
        public final Node statements; // optional

        public LambdaNode(byte[][] locals, Location opening_loc, BlockParametersNode parameters, Node statements, int startOffset, int length) {
            super(startOffset, length);
            this.locals = locals;
            this.opening_loc = opening_loc;
            this.parameters = parameters;
            this.statements = statements;
        }

        public Node[] childNodes() {
            return new Node[] { parameters, statements };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitLambdaNode(this);
        }
    }

    // Represents the use of the `&&=` operator for assignment to a local variable.
    // 
    //     target &&= value
    //     ^^^^^^^^^^^^^^^^
    public static final class LocalVariableOperatorAndWriteNode extends Node {
        public final Location name_loc;
        public final Location operator_loc;
        public final Node value;
        public final byte[] constant_id;

        public LocalVariableOperatorAndWriteNode(Location name_loc, Location operator_loc, Node value, byte[] constant_id, int startOffset, int length) {
            super(startOffset, length);
            this.name_loc = name_loc;
            this.operator_loc = operator_loc;
            this.value = value;
            this.constant_id = constant_id;
        }

        public Node[] childNodes() {
            return new Node[] { value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitLocalVariableOperatorAndWriteNode(this);
        }
    }

    // Represents the use of the `||=` operator for assignment to a local variable.
    // 
    //     target ||= value
    //     ^^^^^^^^^^^^^^^^
    public static final class LocalVariableOperatorOrWriteNode extends Node {
        public final Location name_loc;
        public final Location operator_loc;
        public final Node value;
        public final byte[] constant_id;

        public LocalVariableOperatorOrWriteNode(Location name_loc, Location operator_loc, Node value, byte[] constant_id, int startOffset, int length) {
            super(startOffset, length);
            this.name_loc = name_loc;
            this.operator_loc = operator_loc;
            this.value = value;
            this.constant_id = constant_id;
        }

        public Node[] childNodes() {
            return new Node[] { value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitLocalVariableOperatorOrWriteNode(this);
        }
    }

    // Represents assigning to a local variable using an operator that isn't `=`.
    // 
    //     target += value
    //     ^^^^^^^^^^^^^^^
    public static final class LocalVariableOperatorWriteNode extends Node {
        public final Location name_loc;
        public final Location operator_loc;
        public final Node value;
        public final byte[] constant_id;
        public final byte[] operator_id;

        public LocalVariableOperatorWriteNode(Location name_loc, Location operator_loc, Node value, byte[] constant_id, byte[] operator_id, int startOffset, int length) {
            super(startOffset, length);
            this.name_loc = name_loc;
            this.operator_loc = operator_loc;
            this.value = value;
            this.constant_id = constant_id;
            this.operator_id = operator_id;
        }

        public Node[] childNodes() {
            return new Node[] { value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitLocalVariableOperatorWriteNode(this);
        }
    }

    // Represents reading a local variable. Note that this requires that a local
    // variable of the same name has already been written to in the same scope,
    // otherwise it is parsed as a method call.
    // 
    //     foo
    //     ^^^
    public static final class LocalVariableReadNode extends Node {
        public final byte[] constant_id;
        public final int depth;

        public LocalVariableReadNode(byte[] constant_id, int depth, int startOffset, int length) {
            super(startOffset, length);
            this.constant_id = constant_id;
            this.depth = depth;
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitLocalVariableReadNode(this);
        }
    }

    // Represents writing to a local variable.
    // 
    //     foo = 1
    //     ^^^^^^^
    public static final class LocalVariableWriteNode extends Node {
        public final byte[] constant_id;
        public final int depth;
        public final Node value; // optional
        public final Location name_loc;
        public final Location operator_loc; // optional

        public LocalVariableWriteNode(byte[] constant_id, int depth, Node value, Location name_loc, Location operator_loc, int startOffset, int length) {
            super(startOffset, length);
            this.constant_id = constant_id;
            this.depth = depth;
            this.value = value;
            this.name_loc = name_loc;
            this.operator_loc = operator_loc;
        }

        public Node[] childNodes() {
            return new Node[] { value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitLocalVariableWriteNode(this);
        }
    }

    // Represents the use of the modifier `in` operator.
    // 
    //     foo in bar
    //     ^^^^^^^^^^
    public static final class MatchPredicateNode extends Node {
        public final Node value;
        public final Node pattern;
        public final Location operator_loc;

        public MatchPredicateNode(Node value, Node pattern, Location operator_loc, int startOffset, int length) {
            super(startOffset, length);
            this.value = value;
            this.pattern = pattern;
            this.operator_loc = operator_loc;
        }

        public Node[] childNodes() {
            return new Node[] { value, pattern };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitMatchPredicateNode(this);
        }
    }

    // Represents the use of the `=>` operator.
    // 
    //     foo => bar
    //     ^^^^^^^^^^
    public static final class MatchRequiredNode extends Node {
        public final Node value;
        public final Node pattern;
        public final Location operator_loc;

        public MatchRequiredNode(Node value, Node pattern, Location operator_loc, int startOffset, int length) {
            super(startOffset, length);
            this.value = value;
            this.pattern = pattern;
            this.operator_loc = operator_loc;
        }

        public Node[] childNodes() {
            return new Node[] { value, pattern };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitMatchRequiredNode(this);
        }
    }

    // Represents a node that is missing from the source and results in a syntax
    // error.
    public static final class MissingNode extends Node {

        public MissingNode(int startOffset, int length) {
            super(startOffset, length);
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitMissingNode(this);
        }
    }

    // Represents a module declaration involving the `module` keyword.
    // 
    //     module Foo end
    //     ^^^^^^^^^^^^^^
    public static final class ModuleNode extends Node {
        public final byte[][] locals;
        public final Location module_keyword_loc;
        public final Node constant_path;
        public final Node statements; // optional
        public final Location end_keyword_loc;

        public ModuleNode(byte[][] locals, Location module_keyword_loc, Node constant_path, Node statements, Location end_keyword_loc, int startOffset, int length) {
            super(startOffset, length);
            this.locals = locals;
            this.module_keyword_loc = module_keyword_loc;
            this.constant_path = constant_path;
            this.statements = statements;
            this.end_keyword_loc = end_keyword_loc;
        }

        public Node[] childNodes() {
            return new Node[] { constant_path, statements };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitModuleNode(this);
        }
    }

    // Represents a multi-target expression.
    // 
    //     a, b, c = 1, 2, 3
    //     ^^^^^^^^^^^^^^^^^
    public static final class MultiWriteNode extends Node {
        public final Node[] targets;
        public final Location operator_loc; // optional
        public final Node value; // optional
        public final Location lparen_loc; // optional
        public final Location rparen_loc; // optional

        public MultiWriteNode(Node[] targets, Location operator_loc, Node value, Location lparen_loc, Location rparen_loc, int startOffset, int length) {
            super(startOffset, length);
            this.targets = targets;
            this.operator_loc = operator_loc;
            this.value = value;
            this.lparen_loc = lparen_loc;
            this.rparen_loc = rparen_loc;
        }

        public Node[] childNodes() {
            ArrayList<Node> childNodes = new ArrayList<>();
            childNodes.addAll(Arrays.asList(targets));
            childNodes.add(value);
            return childNodes.toArray(EMPTY_ARRAY);
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitMultiWriteNode(this);
        }
    }

    // Represents the use of the `next` keyword.
    // 
    //     next 1
    //     ^^^^^^
    public static final class NextNode extends Node {
        public final ArgumentsNode arguments; // optional
        public final Location keyword_loc;

        public NextNode(ArgumentsNode arguments, Location keyword_loc, int startOffset, int length) {
            super(startOffset, length);
            this.arguments = arguments;
            this.keyword_loc = keyword_loc;
        }

        public Node[] childNodes() {
            return new Node[] { arguments };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitNextNode(this);
        }
    }

    // Represents the use of the `nil` keyword.
    // 
    //     nil
    //     ^^^
    public static final class NilNode extends Node {

        public NilNode(int startOffset, int length) {
            super(startOffset, length);
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitNilNode(this);
        }
    }

    // Represents the use of `**nil` inside method arguments.
    // 
    //     def a(**nil)
    //           ^^^^^
    //     end
    public static final class NoKeywordsParameterNode extends Node {
        public final Location operator_loc;
        public final Location keyword_loc;

        public NoKeywordsParameterNode(Location operator_loc, Location keyword_loc, int startOffset, int length) {
            super(startOffset, length);
            this.operator_loc = operator_loc;
            this.keyword_loc = keyword_loc;
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitNoKeywordsParameterNode(this);
        }
    }

    // Represents reading a numbered reference to a capture in the previous match.
    // 
    //     $1
    //     ^^
    public static final class NumberedReferenceReadNode extends Node {

        public NumberedReferenceReadNode(int startOffset, int length) {
            super(startOffset, length);
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitNumberedReferenceReadNode(this);
        }
    }

    // Represents an optional parameter to a method, block, or lambda definition.
    // 
    //     def a(b = 1)
    //           ^^^^^
    //     end
    public static final class OptionalParameterNode extends Node {
        public final byte[] constant_id;
        public final Location name_loc;
        public final Location operator_loc;
        public final Node value;

        public OptionalParameterNode(byte[] constant_id, Location name_loc, Location operator_loc, Node value, int startOffset, int length) {
            super(startOffset, length);
            this.constant_id = constant_id;
            this.name_loc = name_loc;
            this.operator_loc = operator_loc;
            this.value = value;
        }

        public Node[] childNodes() {
            return new Node[] { value };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitOptionalParameterNode(this);
        }
    }

    // Represents the use of the `||` operator or the `or` keyword.
    // 
    //     left or right
    //     ^^^^^^^^^^^^^
    public static final class OrNode extends Node {
        public final Node left;
        public final Node right;
        public final Location operator_loc;

        public OrNode(Node left, Node right, Location operator_loc, int startOffset, int length) {
            super(startOffset, length);
            this.left = left;
            this.right = right;
            this.operator_loc = operator_loc;
        }

        public Node[] childNodes() {
            return new Node[] { left, right };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitOrNode(this);
        }
    }

    // Represents the list of parameters on a method, block, or lambda definition.
    // 
    //     def a(b, c, d)
    //           ^^^^^^^
    //     end
    public static final class ParametersNode extends Node {
        public final Node[] requireds;
        public final Node[] optionals;
        public final Node[] posts;
        public final RestParameterNode rest; // optional
        public final Node[] keywords;
        public final Node keyword_rest; // optional
        public final BlockParameterNode block; // optional

        public ParametersNode(Node[] requireds, Node[] optionals, Node[] posts, RestParameterNode rest, Node[] keywords, Node keyword_rest, BlockParameterNode block, int startOffset, int length) {
            super(startOffset, length);
            this.requireds = requireds;
            this.optionals = optionals;
            this.posts = posts;
            this.rest = rest;
            this.keywords = keywords;
            this.keyword_rest = keyword_rest;
            this.block = block;
        }

        public Node[] childNodes() {
            ArrayList<Node> childNodes = new ArrayList<>();
            childNodes.addAll(Arrays.asList(requireds));
            childNodes.addAll(Arrays.asList(optionals));
            childNodes.addAll(Arrays.asList(posts));
            childNodes.add(rest);
            childNodes.addAll(Arrays.asList(keywords));
            childNodes.add(keyword_rest);
            childNodes.add(block);
            return childNodes.toArray(EMPTY_ARRAY);
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitParametersNode(this);
        }
    }

    // Represents a parentesized expression
    // 
    //     (10 + 34)
    //     ^^^^^^^^^
    public static final class ParenthesesNode extends Node {
        public final Node statements; // optional
        public final Location opening_loc;
        public final Location closing_loc;

        public ParenthesesNode(Node statements, Location opening_loc, Location closing_loc, int startOffset, int length) {
            super(startOffset, length);
            this.statements = statements;
            this.opening_loc = opening_loc;
            this.closing_loc = closing_loc;
        }

        public Node[] childNodes() {
            return new Node[] { statements };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitParenthesesNode(this);
        }
    }

    // Represents the use of the `^` operator for pinning an expression in a
    // pattern matching expression.
    // 
    //     foo in ^(bar)
    //            ^^^^^^
    public static final class PinnedExpressionNode extends Node {
        public final Node expression;
        public final Location operator_loc;
        public final Location lparen_loc;
        public final Location rparen_loc;

        public PinnedExpressionNode(Node expression, Location operator_loc, Location lparen_loc, Location rparen_loc, int startOffset, int length) {
            super(startOffset, length);
            this.expression = expression;
            this.operator_loc = operator_loc;
            this.lparen_loc = lparen_loc;
            this.rparen_loc = rparen_loc;
        }

        public Node[] childNodes() {
            return new Node[] { expression };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitPinnedExpressionNode(this);
        }
    }

    // Represents the use of the `^` operator for pinning a variable in a pattern
    // matching expression.
    // 
    //     foo in ^bar
    //            ^^^^
    public static final class PinnedVariableNode extends Node {
        public final Node variable;
        public final Location operator_loc;

        public PinnedVariableNode(Node variable, Location operator_loc, int startOffset, int length) {
            super(startOffset, length);
            this.variable = variable;
            this.operator_loc = operator_loc;
        }

        public Node[] childNodes() {
            return new Node[] { variable };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitPinnedVariableNode(this);
        }
    }

    // Represents the use of the `END` keyword.
    // 
    //     END { foo }
    //     ^^^^^^^^^^^
    public static final class PostExecutionNode extends Node {
        public final StatementsNode statements; // optional
        public final Location keyword_loc;
        public final Location opening_loc;
        public final Location closing_loc;

        public PostExecutionNode(StatementsNode statements, Location keyword_loc, Location opening_loc, Location closing_loc, int startOffset, int length) {
            super(startOffset, length);
            this.statements = statements;
            this.keyword_loc = keyword_loc;
            this.opening_loc = opening_loc;
            this.closing_loc = closing_loc;
        }

        public Node[] childNodes() {
            return new Node[] { statements };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitPostExecutionNode(this);
        }
    }

    // Represents the use of the `BEGIN` keyword.
    // 
    //     BEGIN { foo }
    //     ^^^^^^^^^^^^^
    public static final class PreExecutionNode extends Node {
        public final StatementsNode statements; // optional
        public final Location keyword_loc;
        public final Location opening_loc;
        public final Location closing_loc;

        public PreExecutionNode(StatementsNode statements, Location keyword_loc, Location opening_loc, Location closing_loc, int startOffset, int length) {
            super(startOffset, length);
            this.statements = statements;
            this.keyword_loc = keyword_loc;
            this.opening_loc = opening_loc;
            this.closing_loc = closing_loc;
        }

        public Node[] childNodes() {
            return new Node[] { statements };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitPreExecutionNode(this);
        }
    }

    // The top level node of any parse tree.
    public static final class ProgramNode extends Node {
        public final byte[][] locals;
        public final StatementsNode statements;

        public ProgramNode(byte[][] locals, StatementsNode statements, int startOffset, int length) {
            super(startOffset, length);
            this.locals = locals;
            this.statements = statements;
        }

        public Node[] childNodes() {
            return new Node[] { statements };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitProgramNode(this);
        }
    }

    // Represents the use of the `..` or `...` operators.
    // 
    //     1..2
    //     ^^^^
    // 
    //     c if a =~ /left/ ... b =~ /right/
    //          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    public static final class RangeNode extends Node {
        public final Node left; // optional
        public final Node right; // optional
        public final Location operator_loc;
        public final int flags;

        public RangeNode(Node left, Node right, Location operator_loc, int flags, int startOffset, int length) {
            super(startOffset, length);
            this.left = left;
            this.right = right;
            this.operator_loc = operator_loc;
            this.flags = flags;
        }

        public Node[] childNodes() {
            return new Node[] { left, right };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitRangeNode(this);
        }
    }

    // Represents a rational number literal.
    // 
    //     1.0r
    //     ^^^^
    public static final class RationalNode extends Node {
        public final Node numeric;

        public RationalNode(Node numeric, int startOffset, int length) {
            super(startOffset, length);
            this.numeric = numeric;
        }

        public Node[] childNodes() {
            return new Node[] { numeric };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitRationalNode(this);
        }
    }

    // Represents the use of the `redo` keyword.
    // 
    //     redo
    //     ^^^^
    public static final class RedoNode extends Node {

        public RedoNode(int startOffset, int length) {
            super(startOffset, length);
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitRedoNode(this);
        }
    }

    // Represents a regular expression literal with no interpolation.
    // 
    //     /foo/i
    //     ^^^^^^
    public static final class RegularExpressionNode extends Node {
        public final Location opening_loc;
        public final Location content_loc;
        public final Location closing_loc;
        public final byte[] unescaped;
        public final int flags;

        public RegularExpressionNode(Location opening_loc, Location content_loc, Location closing_loc, byte[] unescaped, int flags, int startOffset, int length) {
            super(startOffset, length);
            this.opening_loc = opening_loc;
            this.content_loc = content_loc;
            this.closing_loc = closing_loc;
            this.unescaped = unescaped;
            this.flags = flags;
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitRegularExpressionNode(this);
        }
    }

    // Represents a destructured required parameter node.
    // 
    //     def foo((bar, baz))
    //             ^^^^^^^^^^
    //     end
    public static final class RequiredDestructuredParameterNode extends Node {
        public final Node[] parameters;
        public final Location opening_loc;
        public final Location closing_loc;

        public RequiredDestructuredParameterNode(Node[] parameters, Location opening_loc, Location closing_loc, int startOffset, int length) {
            super(startOffset, length);
            this.parameters = parameters;
            this.opening_loc = opening_loc;
            this.closing_loc = closing_loc;
        }

        public Node[] childNodes() {
            return parameters;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitRequiredDestructuredParameterNode(this);
        }
    }

    // Represents a required parameter to a method, block, or lambda definition.
    // 
    //     def a(b)
    //           ^
    //     end
    public static final class RequiredParameterNode extends Node {
        public final byte[] constant_id;

        public RequiredParameterNode(byte[] constant_id, int startOffset, int length) {
            super(startOffset, length);
            this.constant_id = constant_id;
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitRequiredParameterNode(this);
        }
    }

    // Represents an expression modified with a rescue.
    // 
    //   foo rescue nil
    //   ^^^^^^^^^^^^^^
    public static final class RescueModifierNode extends Node {
        public final Node expression;
        public final Location keyword_loc;
        public final Node rescue_expression;

        public RescueModifierNode(Node expression, Location keyword_loc, Node rescue_expression, int startOffset, int length) {
            super(startOffset, length);
            this.expression = expression;
            this.keyword_loc = keyword_loc;
            this.rescue_expression = rescue_expression;
        }

        public Node[] childNodes() {
            return new Node[] { expression, rescue_expression };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitRescueModifierNode(this);
        }
    }

    // Represents a rescue statement.
    // 
    //     begin
    //     rescue
    //       foo
    //     ^^^^^^
    //     end
    public static final class RescueNode extends Node {
        public final Location keyword_loc;
        public final Node[] exceptions;
        public final Location operator_loc; // optional
        public final Node exception; // optional
        public final StatementsNode statements; // optional
        public final RescueNode consequent; // optional

        public RescueNode(Location keyword_loc, Node[] exceptions, Location operator_loc, Node exception, StatementsNode statements, RescueNode consequent, int startOffset, int length) {
            super(startOffset, length);
            this.keyword_loc = keyword_loc;
            this.exceptions = exceptions;
            this.operator_loc = operator_loc;
            this.exception = exception;
            this.statements = statements;
            this.consequent = consequent;
        }

        public Node[] childNodes() {
            ArrayList<Node> childNodes = new ArrayList<>();
            childNodes.addAll(Arrays.asList(exceptions));
            childNodes.add(exception);
            childNodes.add(statements);
            childNodes.add(consequent);
            return childNodes.toArray(EMPTY_ARRAY);
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitRescueNode(this);
        }
    }

    // Represents a rest parameter to a method, block, or lambda definition.
    // 
    //     def a(*b)
    //           ^^
    //     end
    public static final class RestParameterNode extends Node {
        public final Location operator_loc;
        public final Location name_loc; // optional

        public RestParameterNode(Location operator_loc, Location name_loc, int startOffset, int length) {
            super(startOffset, length);
            this.operator_loc = operator_loc;
            this.name_loc = name_loc;
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitRestParameterNode(this);
        }
    }

    // Represents the use of the `retry` keyword.
    // 
    //     retry
    //     ^^^^^
    public static final class RetryNode extends Node {

        public RetryNode(int startOffset, int length) {
            super(startOffset, length);
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitRetryNode(this);
        }
    }

    // Represents the use of the `return` keyword.
    // 
    //     return 1
    //     ^^^^^^^^
    public static final class ReturnNode extends Node {
        public final Location keyword_loc;
        public final ArgumentsNode arguments; // optional

        public ReturnNode(Location keyword_loc, ArgumentsNode arguments, int startOffset, int length) {
            super(startOffset, length);
            this.keyword_loc = keyword_loc;
            this.arguments = arguments;
        }

        public Node[] childNodes() {
            return new Node[] { arguments };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitReturnNode(this);
        }
    }

    // Represents the `self` keyword.
    // 
    //     self
    //     ^^^^
    public static final class SelfNode extends Node {

        public SelfNode(int startOffset, int length) {
            super(startOffset, length);
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitSelfNode(this);
        }
    }

    // Represents a singleton class declaration involving the `class` keyword.
    // 
    //     class << self end
    //     ^^^^^^^^^^^^^^^^^
    public static final class SingletonClassNode extends Node {
        public final byte[][] locals;
        public final Location class_keyword_loc;
        public final Location operator_loc;
        public final Node expression;
        public final Node statements; // optional
        public final Location end_keyword_loc;

        public SingletonClassNode(byte[][] locals, Location class_keyword_loc, Location operator_loc, Node expression, Node statements, Location end_keyword_loc, int startOffset, int length) {
            super(startOffset, length);
            this.locals = locals;
            this.class_keyword_loc = class_keyword_loc;
            this.operator_loc = operator_loc;
            this.expression = expression;
            this.statements = statements;
            this.end_keyword_loc = end_keyword_loc;
        }

        public Node[] childNodes() {
            return new Node[] { expression, statements };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitSingletonClassNode(this);
        }
    }

    // Represents the use of the `__ENCODING__` keyword.
    // 
    //     __ENCODING__
    //     ^^^^^^^^^^^^
    public static final class SourceEncodingNode extends Node {

        public SourceEncodingNode(int startOffset, int length) {
            super(startOffset, length);
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitSourceEncodingNode(this);
        }
    }

    // Represents the use of the `__FILE__` keyword.
    // 
    //     __FILE__
    //     ^^^^^^^^
    public static final class SourceFileNode extends Node {
        public final byte[] filepath;

        public SourceFileNode(byte[] filepath, int startOffset, int length) {
            super(startOffset, length);
            this.filepath = filepath;
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitSourceFileNode(this);
        }
    }

    // Represents the use of the `__LINE__` keyword.
    // 
    //     __LINE__
    //     ^^^^^^^^
    public static final class SourceLineNode extends Node {

        public SourceLineNode(int startOffset, int length) {
            super(startOffset, length);
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitSourceLineNode(this);
        }
    }

    // Represents the use of the splat operator.
    // 
    //     [*a]
    //      ^^
    public static final class SplatNode extends Node {
        public final Location operator_loc;
        public final Node expression; // optional

        public SplatNode(Location operator_loc, Node expression, int startOffset, int length) {
            super(startOffset, length);
            this.operator_loc = operator_loc;
            this.expression = expression;
        }

        public Node[] childNodes() {
            return new Node[] { expression };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitSplatNode(this);
        }
    }

    // Represents a set of statements contained within some scope.
    // 
    //     foo; bar; baz
    //     ^^^^^^^^^^^^^
    public static final class StatementsNode extends Node {
        public final Node[] body;

        public StatementsNode(Node[] body, int startOffset, int length) {
            super(startOffset, length);
            this.body = body;
        }

        public Node[] childNodes() {
            return body;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitStatementsNode(this);
        }
    }

    // Represents the use of compile-time string concatenation.
    // 
    //     "foo" "bar"
    //     ^^^^^^^^^^^
    public static final class StringConcatNode extends Node {
        public final Node left;
        public final Node right;

        public StringConcatNode(Node left, Node right, int startOffset, int length) {
            super(startOffset, length);
            this.left = left;
            this.right = right;
        }

        public Node[] childNodes() {
            return new Node[] { left, right };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitStringConcatNode(this);
        }
    }

    // Represents a string literal, a string contained within a `%w` list, or
    // plain string content within an interpolated string.
    // 
    //     "foo"
    //     ^^^^^
    // 
    //     %w[foo]
    //        ^^^
    // 
    //     "foo #{bar} baz"
    //      ^^^^      ^^^^
    public static final class StringNode extends Node {
        public final Location opening_loc; // optional
        public final Location content_loc;
        public final Location closing_loc; // optional
        public final byte[] unescaped;

        public StringNode(Location opening_loc, Location content_loc, Location closing_loc, byte[] unescaped, int startOffset, int length) {
            super(startOffset, length);
            this.opening_loc = opening_loc;
            this.content_loc = content_loc;
            this.closing_loc = closing_loc;
            this.unescaped = unescaped;
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitStringNode(this);
        }
    }

    // Represents the use of the `super` keyword with parentheses or arguments.
    // 
    //     super()
    //     ^^^^^^^
    // 
    //     super foo, bar
    //     ^^^^^^^^^^^^^^
    public static final class SuperNode extends Node {
        public final Location keyword_loc;
        public final Location lparen_loc; // optional
        public final ArgumentsNode arguments; // optional
        public final Location rparen_loc; // optional
        public final BlockNode block; // optional

        public SuperNode(Location keyword_loc, Location lparen_loc, ArgumentsNode arguments, Location rparen_loc, BlockNode block, int startOffset, int length) {
            super(startOffset, length);
            this.keyword_loc = keyword_loc;
            this.lparen_loc = lparen_loc;
            this.arguments = arguments;
            this.rparen_loc = rparen_loc;
            this.block = block;
        }

        public Node[] childNodes() {
            return new Node[] { arguments, block };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitSuperNode(this);
        }
    }

    // Represents a symbol literal or a symbol contained within a `%i` list.
    // 
    //     :foo
    //     ^^^^
    // 
    //     %i[foo]
    //        ^^^
    public static final class SymbolNode extends Node {
        public final Location opening_loc; // optional
        public final Location value_loc;
        public final Location closing_loc; // optional
        public final byte[] unescaped;

        public SymbolNode(Location opening_loc, Location value_loc, Location closing_loc, byte[] unescaped, int startOffset, int length) {
            super(startOffset, length);
            this.opening_loc = opening_loc;
            this.value_loc = value_loc;
            this.closing_loc = closing_loc;
            this.unescaped = unescaped;
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitSymbolNode(this);
        }
    }

    // Represents the use of the literal `true` keyword.
    // 
    //     true
    //     ^^^^
    public static final class TrueNode extends Node {

        public TrueNode(int startOffset, int length) {
            super(startOffset, length);
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitTrueNode(this);
        }
    }

    // Represents the use of the `undef` keyword.
    // 
    //     undef :foo, :bar, :baz
    //     ^^^^^^^^^^^^^^^^^^^^^^
    public static final class UndefNode extends Node {
        public final Node[] names;
        public final Location keyword_loc;

        public UndefNode(Node[] names, Location keyword_loc, int startOffset, int length) {
            super(startOffset, length);
            this.names = names;
            this.keyword_loc = keyword_loc;
        }

        public Node[] childNodes() {
            return names;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitUndefNode(this);
        }
    }

    // Represents the use of the `unless` keyword, either in the block form or the modifier form.
    // 
    //     bar unless foo
    //     ^^^^^^^^^^^^^^
    // 
    //     unless foo then bar end
    //     ^^^^^^^^^^^^^^^^^^^^^^^
    public static final class UnlessNode extends Node {
        public final Location keyword_loc;
        public final Node predicate;
        public final StatementsNode statements; // optional
        public final ElseNode consequent; // optional
        public final Location end_keyword_loc; // optional

        public UnlessNode(Location keyword_loc, Node predicate, StatementsNode statements, ElseNode consequent, Location end_keyword_loc, int startOffset, int length) {
            super(startOffset, length);
            this.keyword_loc = keyword_loc;
            this.predicate = predicate;
            this.statements = statements;
            this.consequent = consequent;
            this.end_keyword_loc = end_keyword_loc;
        }

        public Node[] childNodes() {
            return new Node[] { predicate, statements, consequent };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitUnlessNode(this);
        }
    }

    // Represents the use of the `until` keyword, either in the block form or the modifier form.
    // 
    //     bar until foo
    //     ^^^^^^^^^^^^^
    // 
    //     until foo do bar end
    //     ^^^^^^^^^^^^^^^^^^^^
    public static final class UntilNode extends Node {
        public final Location keyword_loc;
        public final Node predicate;
        public final StatementsNode statements; // optional

        public UntilNode(Location keyword_loc, Node predicate, StatementsNode statements, int startOffset, int length) {
            super(startOffset, length);
            this.keyword_loc = keyword_loc;
            this.predicate = predicate;
            this.statements = statements;
        }

        public Node[] childNodes() {
            return new Node[] { predicate, statements };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitUntilNode(this);
        }
    }

    // case true
    // when true
    // ^^^^^^^^^
    // end
    public static final class WhenNode extends Node {
        public final Location keyword_loc;
        public final Node[] conditions;
        public final StatementsNode statements; // optional

        public WhenNode(Location keyword_loc, Node[] conditions, StatementsNode statements, int startOffset, int length) {
            super(startOffset, length);
            this.keyword_loc = keyword_loc;
            this.conditions = conditions;
            this.statements = statements;
        }

        public Node[] childNodes() {
            ArrayList<Node> childNodes = new ArrayList<>();
            childNodes.addAll(Arrays.asList(conditions));
            childNodes.add(statements);
            return childNodes.toArray(EMPTY_ARRAY);
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitWhenNode(this);
        }
    }

    // Represents the use of the `while` keyword, either in the block form or the modifier form.
    // 
    //     bar while foo
    //     ^^^^^^^^^^^^^
    // 
    //     while foo do bar end
    //     ^^^^^^^^^^^^^^^^^^^^
    public static final class WhileNode extends Node {
        public final Location keyword_loc;
        public final Node predicate;
        public final StatementsNode statements; // optional

        public WhileNode(Location keyword_loc, Node predicate, StatementsNode statements, int startOffset, int length) {
            super(startOffset, length);
            this.keyword_loc = keyword_loc;
            this.predicate = predicate;
            this.statements = statements;
        }

        public Node[] childNodes() {
            return new Node[] { predicate, statements };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitWhileNode(this);
        }
    }

    // Represents an xstring literal with no interpolation.
    // 
    //     `foo`
    //     ^^^^^
    public static final class XStringNode extends Node {
        public final Location opening_loc;
        public final Location content_loc;
        public final Location closing_loc;
        public final byte[] unescaped;

        public XStringNode(Location opening_loc, Location content_loc, Location closing_loc, byte[] unescaped, int startOffset, int length) {
            super(startOffset, length);
            this.opening_loc = opening_loc;
            this.content_loc = content_loc;
            this.closing_loc = closing_loc;
            this.unescaped = unescaped;
        }

        public Node[] childNodes() {
            return EMPTY_ARRAY;
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitXStringNode(this);
        }
    }

    // Represents the use of the `yield` keyword.
    // 
    //     yield 1
    //     ^^^^^^^
    public static final class YieldNode extends Node {
        public final Location keyword_loc;
        public final Location lparen_loc; // optional
        public final ArgumentsNode arguments; // optional
        public final Location rparen_loc; // optional

        public YieldNode(Location keyword_loc, Location lparen_loc, ArgumentsNode arguments, Location rparen_loc, int startOffset, int length) {
            super(startOffset, length);
            this.keyword_loc = keyword_loc;
            this.lparen_loc = lparen_loc;
            this.arguments = arguments;
            this.rparen_loc = rparen_loc;
        }

        public Node[] childNodes() {
            return new Node[] { arguments };
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visitYieldNode(this);
        }
    }

}
// @formatter:on
